######################################### EMPLOYEE CLASS ######################################################
class Employee:

    def __init__(self, empID:str, lName:str, fName:str, regHours:float, hourlyRate:float,
     otMultiple:float, taxCredit:float, standardBand:float):

        self.empID = empID
        self.lName = lName
        self.fName = fName
        self.regHours = regHours
        self.hourlyRate = hourlyRate
        self.otMultiple = otMultiple
        self.taxCredit = taxCredit
        self.standardBand = standardBand

        # check for negative values
        if regHours < 0 or \
        hourlyRate < 0 or \
            otMultiple < 0 or \
                taxCredit < 0 or \
                    standardBand < 0 :
                    #if negative values found, notify
            raise ValueError("Invalid value check : Employee " + empID)


    def computePayment(self, hoursWorked:float, dateWorked:str):

        regularHrsWorked = 0
        regularPay = 0
        otHrsWorked = 0
        otRate = self.hourlyRate * self.otMultiple
        otPay = 0

        if hoursWorked > self.regHours:
            
            regularHrsWorked = self.regHours #regular hours worked cannot be greater than regular hours
            otHrsWorked = hoursWorked - self.regHours #overtime hours = total hours worked - regular hours
            otPay = otHrsWorked * otRate #calc ovetime pay
            regularPay = regularHrsWorked * self.hourlyRate #calc regular pay
        
        else:

            regularHrsWorked = hoursWorked #hours worked <= reg. hours worked, then hours worked = regular hours
            regularPay = hoursWorked * self.hourlyRate #calc regular pay

        grossPay = regularPay + otPay
        higherRatePay = grossPay - self.standardBand if grossPay > self.standardBand else 0
        # if gross pay > standard band, higher pay rate = earnings above gross pay else higher rate earnings

        standardTax = 0.2 * (self.standardBand if higherRatePay != 0 else grossPay)
        # if gross pay < standard band, tax applicable only on amount below standard band
        # else tax applicable on full band amount

        higherTax = 0.4 * (higherRatePay if higherRatePay != 0 else 0)
        # if higher pay == 0, no higher tax applicable

        netDeductions = standardTax + higherTax - self.taxCredit if standardTax + higherTax >= self.taxCredit else standardTax + higherTax
        # if total taxes >= tax credits, deductions = total taxes - tax credits;
        # else deductions = total taxes 

        return dict({
            "name" : self.fName + " " + self.lName,
            "date" : dateWorked,
            "regular hrs worked" : regularHrsWorked,
            "ot hrs worked" : otHrsWorked,
            "regular rate" : self.hourlyRate,
            "ot rate" : otRate,
            "regular pay" : regularPay,
            "ot pay" : otPay,
            "gross pay" : grossPay,
            "std rate pay" : self.standardBand,
            "higher rate pay" : higherRatePay,
            "standard tax" : standardTax,
            "higher tax" : higherTax,
            "total tax" : standardTax + higherTax,
            "tax credit" : self.taxCredit,
            "net deductions" : netDeductions,
            "net pay" : grossPay - netDeductions
        })
########################################### EMPLOYEE CLASS ######################################################


def computeAllPayments(employeeFile:str, hoursFile:str):

    empObjectDict = {} #all emp objects read from file stored here
    hrsObjectDict = {} #all hours data read from file stored here

    ############################## READ FROM EMPLOYEE AND HOURS FILE ######################################################
    try:
        with open(employeeFile, "r") as emp:
            empList = [] #store lines read from emp file here

            for item in emp: #line in employees.txt
                empList.append(item)

            for item in empList: #field line in above array

                empDetails = [] #convert each line read into a list, store here
                empDetails = item.split() 

                try:
                    empObject = Employee(empDetails[0],empDetails[1],empDetails[2]
                        ,float(empDetails[3]),float(empDetails[4]),float(empDetails[5])
                        ,float(empDetails[6]),float(empDetails[7]))
                #Employee object CTR:
                #Employee(empID: str, lName: str, fName: str, regHours: float, 
                        #hourlyRate: float, otMultiple: float, taxCredit: float, standardBand: float)

                except TypeError as e : #catch alphabets/alphanumeric conversion errors
                    print(e)
                    print(1)
                    quit()
                except ValueError as e : #catch errors generated by negative input values
                    print(e)
                    print(2)
                    quit()
                except Exception as e:
                    print(e)
                    print(3)
                    quit()

                empObjectDict[empDetails[0]] = empObject #add employee object to emp object dictionary {empid : empobject}

        with open(hoursFile, "r") as hrs:
            hoursList = [] #store hours data here

            for item in hrs: #line in hours.txt
                lis = item.split() #convert line to a list
                hoursList.append(lis)

            for item in hoursList:
                empID = item[0]

                if empID not in hrsObjectDict.keys():
                    hrsObjectDict[empID] = [] # create empty list for first occurance of the empid, 
                                                #or else the append function below doesnt work

                hrsObjectDict[empID].append(item) # map hours data with its empid {empid1 : [[h1],[h2],[h3]]},
                                                                                # {empid2 : [[h1],[h2],[h3]]}

    except FileNotFoundError as e:
        print(e)
        print(4)
        quit()
    #########################################################################################################################

    ############################## GENERATE EMPLOYEE PAYMENT DETAILS FROM DICITONARIES ########################################

    computedWages = [] #store all the computed wages in this list

    for k, v in hrsObjectDict.items(): #compute wages by looping through the hours dictionary
        empID = k #emp id
        empHrs = v #list of hours worked wrt date

        if empID not in empObjectDict.keys(): #check for data entered for invalid employee id
            continue
        
        for item in empHrs:
            try:
                if float(item[2]) < 0: #check for negative hours input, notify in case
                    raise ValueError("Invalid hours worked for : " + str(item))

                computedWages.append(empObjectDict[empID].computePayment(float(item[2]), item[1])) #append successful computation here

            except Exception as e:
                print(e)
                print(5)
                quit()

    ###########################################################################################################
    print(str(computedWages)) #print consolidated computation




computeAllPayments("./employees.txt", "./hours.txt")